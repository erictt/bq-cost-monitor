/**
 * Provides SQL snippets and best practices for optimizing BigQuery queries to reduce costs
 * 
 * This module can be used in dataform projects to add cost optimization features
 * to SQL queries and provide best practices for BigQuery usage.
 */

/**
 * Generate a SQL comment with optimization tips
 * @returns {string} SQL comment with optimization tips
 */
function optimizationTips() {
  return `
-- BigQuery Cost Optimization Tips:
-- 1. Use LIMIT when exploring data to reduce bytes processed
-- 2. Use column selection instead of SELECT * to reduce bytes processed
-- 3. Use partitioned and clustered tables when possible
-- 4. Use cache by running identical queries within 24 hours
-- 5. Use approximate aggregation functions when exact precision isn't required
-- 6. Filter early in your query to reduce the amount of data processed
-- 7. Use table wildcards with caution as they can lead to processing more data than needed
-- 8. Consider materializing commonly used subqueries or CTEs
-- 9. Use incremental builds instead of full rebuilds when possible
-- 10. Monitor query costs with BigQuery Cost Monitor
`;
}

/**
 * Add a cost estimation comment to a query
 * @param {string} query - The SQL query
 * @param {Object} options - Options for cost estimation
 * @param {number} options.estimatedTB - Estimated terabytes processed
 * @param {number} options.costPerTB - Cost per terabyte
 * @returns {string} Query with cost estimation comment
 */
function addCostEstimation(query, options = {}) {
  const { 
    estimatedTB = 'X', 
    costPerTB = 5 
  } = options;
  
  const estimatedCost = typeof estimatedTB === 'number' ? 
    `$${(estimatedTB * costPerTB).toFixed(2)}` : 
    '$Y';
  
  return `
-- Cost Estimation:
-- This query will process approximately ${estimatedTB} TB of data
-- Estimated cost: ${estimatedCost} USD (at $${costPerTB} per TB)

${query}
`;
}

/**
 * Add project and team tagging to a query
 * @param {string} query - The SQL query
 * @param {string} projectId - The project ID
 * @param {string} teamName - The team name
 * @param {Object} options - Additional options
 * @param {string} options.owner - Query owner
 * @param {string} options.purpose - Query purpose
 * @returns {string} Query with tagging
 */
function addQueryTagging(query, projectId, teamName, options = {}) {
  const { owner = '', purpose = '' } = options;
  
  let tagging = `
-- Query for project: ${projectId}
-- Team: ${teamName}
-- Generated by cost-monitor
`;

  if (owner) {
    tagging += `-- Owner: ${owner}\n`;
  }
  
  if (purpose) {
    tagging += `-- Purpose: ${purpose}\n`;
  }
  
  return tagging + '\n' + query;
}

/**
 * Generate a SQL snippet for checking bytes processed before running a query
 * @param {Object} options - Options for dry run
 * @param {string} options.tableId - Table ID to check
 * @param {number} options.costPerTB - Cost per terabyte
 * @returns {string} SQL snippet for dry run
 */
function dryRunCheck(options = {}) {
  const { 
    tableId = 'your_table',
    costPerTB = 5
  } = options;
  
  return `
-- To check bytes processed before running:
/*
#standardSQL
SELECT
  total_bytes_processed,
  total_bytes_processed / POWER(1024, 4) AS terabytes_processed,
  (total_bytes_processed / POWER(1024, 4)) * ${costPerTB} AS estimated_cost_usd
FROM (
  SELECT total_bytes_processed
  FROM \`region-us\`.__TABLES__
  WHERE table_id = '${tableId}'
)
*/
`;
}

/**
 * Generate a SQL snippet for a query with partitioning filter
 * @param {string} query - The SQL query
 * @param {string} partitionColumn - The partition column
 * @param {string} partitionFilter - The partition filter expression
 * @returns {string} Query with partition filter
 */
function addPartitionFilter(query, partitionColumn, partitionFilter) {
  // Check if the query already has a WHERE clause
  const hasWhere = /\bWHERE\b/i.test(query);
  
  if (hasWhere) {
    // Add the partition filter to the existing WHERE clause
    return query.replace(
      /\bWHERE\b/i, 
      `WHERE ${partitionColumn} ${partitionFilter} AND `
    );
  } else {
    // Find the FROM clause and add a WHERE clause after it
    const fromMatch = query.match(/\bFROM\b.*?(?=\b(GROUP|ORDER|LIMIT|HAVING|QUALIFY|WINDOW)\b|$)/is);
    
    if (fromMatch) {
      const fromClause = fromMatch[0];
      return query.replace(
        fromClause,
        `${fromClause} WHERE ${partitionColumn} ${partitionFilter}`
      );
    }
  }
  
  // If we couldn't find a good place to add the filter, return the original query
  return query;
}

/**
 * Generate a SQL snippet for an incremental build
 * @param {string} query - The SQL query for a full build
 * @param {string} incrementalColumn - The column to use for incremental filtering
 * @param {string} incrementalPredicate - The predicate for incremental filtering
 * @returns {string} Query modified for incremental build
 */
function makeIncremental(query, incrementalColumn, incrementalPredicate) {
  return `
-- Incremental build query
-- Only processes new/changed data since last build
${query.trim()}
${getIncrementalWhereClause(incrementalColumn, incrementalPredicate)}
`;
}

/**
 * Generate a WHERE clause for incremental builds
 * @param {string} incrementalColumn - The column to use for incremental filtering
 * @param {string} incrementalPredicate - The predicate for incremental filtering
 * @returns {string} WHERE clause for incremental build
 */
function getIncrementalWhereClause(incrementalColumn, incrementalPredicate) {
  return `
-- Add this WHERE clause for incremental builds
-- WHERE ${incrementalColumn} ${incrementalPredicate}
`;
}

/**
 * Generate a SQL snippet for a query with a LIMIT clause for exploration
 * @param {string} query - The SQL query
 * @param {number} limit - The limit to apply
 * @returns {string} Query with LIMIT clause
 */
function addExplorationLimit(query, limit = 1000) {
  // Check if the query already has a LIMIT clause
  if (/\bLIMIT\b\s+\d+/i.test(query)) {
    return query;
  }
  
  return `${query.trim()}\nLIMIT ${limit}`;
}

/**
 * Generate a SQL snippet for a query with cost monitoring instrumentation
 * @param {string} query - The SQL query
 * @param {Object} options - Options for instrumentation
 * @param {string} options.queryId - Query identifier
 * @param {string} options.queryType - Query type (e.g., 'report', 'etl')
 * @returns {string} Query with cost monitoring instrumentation
 */
function addCostMonitoring(query, options = {}) {
  const { 
    queryId = 'query_id', 
    queryType = 'adhoc' 
  } = options;
  
  return `
-- Query instrumented for cost monitoring
-- Query ID: ${queryId}
-- Query Type: ${queryType}
-- Execution Time: ${new Date().toISOString()}

${query}
`;
}

module.exports = {
  optimizationTips,
  addCostEstimation,
  addQueryTagging,
  dryRunCheck,
  addPartitionFilter,
  makeIncremental,
  getIncrementalWhereClause,
  addExplorationLimit,
  addCostMonitoring
};
